<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wishing Well - Golden Coin Drop</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(180deg, #4DD0E1 0%, #26C6DA 100%);
            font-family: Arial, sans-serif;
        }
        
        .container {
            position: relative;
            width: 400px;
            height: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .controls {
            position: absolute;
            bottom: 30px;
            display: flex;
            gap: 15px;
        }
        
        button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: 3px solid #DAA520;
            border-radius: 50px;
            color: #8B4513;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
            transition: all 0.3s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.6);
        }
        
        button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas" width="400" height="600"></canvas>
        <div class="controls">
            <button onclick="dropCoin()">æŠ•å¹£è¨±é¡˜ ğŸ’°</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let coins = [];
        let waterDrops = [];
        let ripples = [];
        let sparkles = [];
        let floatingLights = [];
        
        const wellY = 380;
        const wellCenterX = 200;
        const wellWidth = 120;
        const wellHeight = 35;
        
        class Coin {
            constructor() {
                this.x = wellCenterX;
                this.y = 80;
                this.radius = 22;
                this.velocity = 0;
                this.gravity = 0.5;
                this.rotation = 0;
                this.rotationSpeed = 0.12;
                this.hasHitWater = false;
                this.opacity = 1;
                this.scale = 1;
            }
            
            update() {
                if (!this.hasHitWater) {
                    this.velocity += this.gravity;
                    this.y += this.velocity;
                    this.rotation += this.rotationSpeed;
                    
                    if (this.y >= wellY - 20) {
                        this.hasHitWater = true;
                        this.createSplash();
                    }
                } else {
                    this.y += 1.5;
                    this.opacity -= 0.015;
                    this.scale -= 0.01;
                }
            }
            
            createSplash() {
                // æ°´èŠ±
                for (let i = 0; i < 25; i++) {
                    const angle = (Math.PI * 2 * i) / 25;
                    const speed = 2 + Math.random() * 4;
                    waterDrops.push(new WaterDrop(this.x, wellY - 15, angle, speed));
                }
                
                // æ–·æ–·çºŒçºŒçš„å¼§å½¢æ¼£æ¼ª
                for (let i = 0; i < 4; i++) {
                    setTimeout(() => {
                        ripples.push(new SegmentedRipple(this.x, wellY));
                    }, i * 150);
                }
                
                // ç”¢ç”Ÿæ›´å¤šæµ®å‹•å…‰é»
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        floatingLights.push(new FloatingLight());
                    }, i * 100);
                }
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                
                // é‡‘å¹£é™°å½±
                ctx.shadowColor = 'rgba(218, 165, 32, 0.6)';
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 8;
                
                // é‡‘å¹£å´é¢åšåº¦ï¼ˆä¸‹æ–¹æ·±è‰²éƒ¨åˆ†ï¼‰- å…ˆç•«åšåº¦å±¤
                const thicknessGradient = ctx.createLinearGradient(0, 2, 0, 6);
                thicknessGradient.addColorStop(0, '#B8860B');
                thicknessGradient.addColorStop(0.5, '#8B6914');
                thicknessGradient.addColorStop(1, '#6B5610');
                
                ctx.fillStyle = thicknessGradient;
                ctx.beginPath();
                ctx.ellipse(0, 3, this.radius, this.radius * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // é‡‘å¹£ä¸»é«” - å¯¦å¿ƒæ©¢åœ“å½¢ï¼Œé‡‘è‰²æ¼¸å±¤
                const mainGradient = ctx.createRadialGradient(-8, -5, 0, 0, 0, this.radius);
                mainGradient.addColorStop(0, '#FFF9E6');
                mainGradient.addColorStop(0.3, '#FFD700');
                mainGradient.addColorStop(0.6, '#FFC107');
                mainGradient.addColorStop(0.85, '#FF9800');
                mainGradient.addColorStop(1, '#B8860B');
                
                ctx.fillStyle = mainGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius, this.radius * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // é‡‘å¹£å¤–åœˆæ·±è‰²é‚Šç·£
                ctx.strokeStyle = '#8B6914';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius, this.radius * 0.4, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // é‡‘å¹£å´é‚Šé½’ç´‹ï¼ˆå¢åŠ çœŸå¯¦ç¡¬å¹£çš„æ„Ÿè¦ºï¼‰
                ctx.strokeStyle = 'rgba(139, 105, 20, 0.5)';
                ctx.lineWidth = 0.8;
                for (let i = 0; i < 16; i++) {
                    const angle = (Math.PI * 2 * i) / 16;
                    const x1 = Math.cos(angle) * this.radius * 0.95;
                    const y1 = Math.sin(angle) * this.radius * 0.4 * 0.95;
                    const x2 = Math.cos(angle) * this.radius;
                    const y2 = Math.sin(angle) * this.radius * 0.4 + 2.5;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
                
                // å…§åœˆè£é£¾
                ctx.strokeStyle = '#DAA520';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius - 4, (this.radius - 4) * 0.4, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // ä¸­å¿ƒå°æ©¢åœ“è£é£¾
                const centerGradient = ctx.createRadialGradient(0, -1, 0, 0, -1, 6);
                centerGradient.addColorStop(0, '#FFFACD');
                centerGradient.addColorStop(0.5, '#FFD700');
                centerGradient.addColorStop(1, '#DAA520');
                
                ctx.fillStyle = centerGradient;
                ctx.beginPath();
                ctx.ellipse(0, -1, 6, 2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // é«˜å…‰æ•ˆæœï¼ˆè®“é‡‘å¹£æ›´ç«‹é«”ï¼‰
                const highlightGradient = ctx.createRadialGradient(-10, -5, 0, -10, -5, 12);
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.85)');
                highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = highlightGradient;
                ctx.beginPath();
                ctx.ellipse(-10, -5, 12, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        class WaterDrop {
            constructor(x, y, angle, speed) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed - 6;
                this.gravity = 0.5;
                this.radius = 2 + Math.random() * 3;
                this.opacity = 1;
                this.life = 1;
            }
            
            update() {
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.025;
                this.opacity = this.life;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                // æ°´æ»´ä¸»é«”
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // æ°´æ»´é«˜å…‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(this.x - 0.5, this.y - 0.5, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        class SegmentedRipple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.maxRadius = 100;
                this.opacity = 1;
                this.speed = 2.5;
                this.segments = 6;
            }
            
            update() {
                this.radius += this.speed;
                this.opacity = 1 - (this.radius / this.maxRadius);
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                
                const segmentAngle = (Math.PI * 2) / this.segments;
                const gapAngle = segmentAngle * 0.3;
                
                for (let i = 0; i < this.segments; i++) {
                    const startAngle = i * segmentAngle;
                    const endAngle = startAngle + segmentAngle - gapAngle;
                    
                    ctx.beginPath();
                    ctx.ellipse(
                        this.x, 
                        this.y, 
                        this.radius, 
                        this.radius * 0.35, 
                        0, 
                        startAngle, 
                        endAngle
                    );
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        class Sparkle {
            constructor(x, y) {
                this.x = x + (Math.random() - 0.5) * 50;
                this.y = y + (Math.random() - 0.5) * 50;
                this.size = 1.5 + Math.random() * 2;
                this.opacity = 1;
                this.life = 1;
                this.twinkle = Math.random() * Math.PI * 2;
                this.color = Math.random() > 0.3 ? '#FFD700' : '#FFFFFF';
            }
            
            update() {
                this.life -= 0.015;
                this.opacity = Math.sin(this.twinkle) * this.life;
                this.twinkle += 0.15;
                this.y -= 0.3;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = Math.abs(this.opacity);
                
                // æ˜Ÿæ˜Ÿä¸»é«”
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // åå­—æ˜Ÿå…‰
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.x - this.size * 2.5, this.y);
                ctx.lineTo(this.x + this.size * 2.5, this.y);
                ctx.moveTo(this.x, this.y - this.size * 2.5);
                ctx.lineTo(this.x, this.y + this.size * 2.5);
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        class FloatingLight {
            constructor() {
                this.x = wellCenterX + (Math.random() - 0.5) * wellWidth * 2;
                this.y = wellY + 20;
                this.size = 2 + Math.random() * 3;
                this.vy = -0.5 - Math.random() * 1.5;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.life = 1;
                this.opacity = 0;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            
            update() {
                this.y += this.vy;
                this.x += this.vx;
                this.life -= 0.003;
                this.twinkle += 0.1;
                
                if (this.y > wellY - 50 && this.y < wellY + 50) {
                    this.opacity = Math.min(1, this.opacity + 0.05);
                } else {
                    this.opacity = Math.max(0, this.opacity - 0.02);
                }
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity * Math.abs(Math.sin(this.twinkle));
                
                // å…‰æšˆ
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 3);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.6)');
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 3, 0, Math.PI * 2);
                ctx.fill();
                
                // æ ¸å¿ƒå…‰é»
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function drawWell() {
            // è¨±é¡˜äº•çš„æ°´é¢ï¼ˆæ©¢åœ“å½¢ï¼‰
            ctx.fillStyle = 'rgba(38, 198, 218, 0.4)';
            ctx.beginPath();
            ctx.ellipse(wellCenterX, wellY, wellWidth, wellHeight, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // æ°´é¢å…‰æ¾¤
            ctx.fillStyle = 'rgba(77, 208, 225, 0.5)';
            ctx.beginPath();
            ctx.ellipse(wellCenterX, wellY - 5, wellWidth * 0.8, wellHeight * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // è¨±é¡˜äº•å¤–åœï¼ˆæ–·æ–·çºŒçºŒçš„å¼§å½¢ï¼Œå…±3å±¤ï¼‰
            for (let layer = 0; layer < 3; layer++) {
                const layerRadius = wellWidth + layer * 25;
                const layerHeight = wellHeight + layer * 8;
                const segments = 6;
                const segmentAngle = (Math.PI * 2) / segments;
                const gapAngle = segmentAngle * 0.35;
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 - layer * 0.1})`;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                for (let i = 0; i < segments; i++) {
                    const startAngle = i * segmentAngle;
                    const endAngle = startAngle + segmentAngle - gapAngle;
                    
                    ctx.beginPath();
                    ctx.ellipse(
                        wellCenterX, 
                        wellY + 15 + layer * 5, 
                        layerRadius, 
                        layerHeight, 
                        0, 
                        startAngle, 
                        endAngle
                    );
                    ctx.stroke();
                }
            }
            
            // èƒŒæ™¯æ˜Ÿæ˜Ÿ
            drawBackgroundStars();
        }
        
        function drawBackgroundStars() {
            const stars = [
                {x: 70, y: 90, size: 1.5},
                {x: 130, y: 70, size: 2},
                {x: 110, y: 130, size: 1.5},
                {x: 280, y: 100, size: 2},
                {x: 330, y: 80, size: 1.5},
                {x: 300, y: 140, size: 2},
                {x: 90, y: 200, size: 1.5},
                {x: 310, y: 190, size: 1.5}
            ];
            
            stars.forEach(star => {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                
                // åå­—å…‰èŠ’
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(star.x - star.size * 2, star.y);
                ctx.lineTo(star.x + star.size * 2, star.y);
                ctx.moveTo(star.x, star.y - star.size * 2);
                ctx.lineTo(star.x, star.y + star.size * 2);
                ctx.stroke();
            });
        }
        
        function dropCoin() {
            const coin = new Coin();
            coins.push(coin);
            
            // æŠ•å¹£æ™‚çš„æ˜Ÿæ˜Ÿç‰¹æ•ˆï¼ˆæ›´å¤šé‡‘è‰²æ˜Ÿæ˜Ÿï¼‰
            for (let i = 0; i < 15; i++) {
                sparkles.push(new Sparkle(wellCenterX, 80));
            }
        }
        
        // å®šæœŸç”¢ç”Ÿæµ®å‹•å…‰é»
        setInterval(() => {
            if (Math.random() > 0.7) {
                floatingLights.push(new FloatingLight());
            }
        }, 300);
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawWell();
            
            // æµ®å‹•å…‰é»
            floatingLights = floatingLights.filter(light => {
                light.update();
                if (light.life > 0 && light.y > -50) {
                    light.draw();
                    return true;
                }
                return false;
            });
            
            // æ˜Ÿæ˜Ÿ
            sparkles = sparkles.filter(sparkle => {
                sparkle.update();
                if (sparkle.life > 0) {
                    sparkle.draw();
                    return true;
                }
                return false;
            });
            
            // é‡‘å¹£
            coins = coins.filter(coin => {
                coin.update();
                if (coin.opacity > 0) {
                    coin.draw();
                    return true;
                }
                return false;
            });
            
            // æ°´æ»´
            waterDrops = waterDrops.filter(drop => {
                drop.update();
                if (drop.life > 0) {
                    drop.draw();
                    return true;
                }
                return false;
            });
            
            // æ¼£æ¼ª
            ripples = ripples.filter(ripple => {
                ripple.update();
                if (ripple.radius < ripple.maxRadius) {
                    ripple.draw();
                    return true;
                }
                return false;
            });
            
            requestAnimationFrame(animate);
        }
        
        animate();
        
        // è‡ªå‹•æ¼”ç¤º
        setTimeout(() => {
            dropCoin();
        }, 500);
    </script>
</body>
</html>
